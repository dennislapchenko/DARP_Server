//
//  HandleServerRegistration.cs
//
//  Author:
//       Dennis Lapchenko <>
//
//  Copyright (c) 2015 Dennis Lapchenko
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
//
// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using MMO.Photon.Server;
using MMO.Framework;
using MMO.Photon.Application;
using Photon.SocketServer;
using SubServerCommon.Operations;
using ComplexServerCommon;
using System.Xml.Serialization;
using System.IO;
using SubServerCommon.Data;
using SubServerCommon;


namespace ComplexServer.Handlers
{
	public class HandleServerRegistration : PhotonServerHandler
	{
		public HandleServerRegistration (PhotonApplication application) : base(application)
		{

		}
		#region implemented abstract members of PhotonServerHandler

		protected override bool OnHandleMessage (IMessage message, PhotonServerPeer serverPeer)
		{
			OperationResponse operationResponse;
			if (serverPeer.ServerId.HasValue)
			{
				operationResponse = new OperationResponse(message.Code) { ReturnCode = -1, DebugMessage = "Already Registered"};
			}
			else
			{
				var registerRequest = new RegisterSubServer(serverPeer.Protocol, message);
				if (!registerRequest.IsValid)
				{
					string msg = registerRequest.GetErrorMessage();
					if (Log.IsDebugEnabled)
					{
						Log.DebugFormat("Invalid Register Request: {0}", msg);
					}

					operationResponse = new OperationResponse(message.Code) { DebugMessage = msg, ReturnCode = (short)ErrorCode.OperationInvalid};
				}
				else
				{
					var registerData = Xml.Deserialize<RegisterSubServerData>(registerRequest.RegisterSubServerOperation);
					if (Log.IsDebugEnabled)
					{
						Log.DebugFormat("Received register request: Address={0}, UdpPort={2}, TcpPort={1}, Type={3}",
						    registerData.GameServerAddress, registerData.TcpPort, registerData.UdpPort, registerData.ServerType);
					}
					if (registerData.UdpPort.HasValue)
					{
						serverPeer.UdpAddress = registerData.GameServerAddress + ":" + registerData.UdpPort;
					}
					if (registerData.TcpPort.HasValue)
					{
						serverPeer.TcpAddress = registerData.GameServerAddress + ":" + registerData.TcpPort;
					}
					serverPeer.ServerId = registerData.ServerId;
					serverPeer.ServerType = registerData.ServerType;

					serverPeer.ApplicationName = registerData.ApplicationName;
					Server.ConnectionCollection<PhotonConnectionCollection>().OnConnect(serverPeer);
					operationResponse = new OperationResponse(message.Code);
				}
			}
			serverPeer.SendOperationResponse(operationResponse, new SendParameters());
			return true;
		}

		public override MessageType Type {
			get {
				return MessageType.Request;
			}
		}

		public override byte Code {
			get {
				return (byte)ServerOperationCode.RegisterSubServer;
			}
		}

		public override int? SubCode {
			get {
				return null;
			}
		}

		#endregion


	}
}

